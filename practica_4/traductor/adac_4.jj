//*****************************************************************
// File:   adac_4.jj
// Author: Nerea Gallego, César Borja
// Date:   ...........
// Coms:   Un tutorial sobre el análisis léxico con javacc
//         https://javacc.github.io/javacc/tutorials/token-manager.html
//*****************************************************************

options {
   DEBUG_PARSER = false;
}

PARSER_BEGIN(adac_4)
package traductor;

import java.util.*;
import java.lang.Integer.*;
import java.lang.Exception.*;
import java.io.IOException;
import java.lang.String;
import lib.symbolTable.*;
import lib.symbolTable.exceptions.*;
import lib.errores.*;
import lib.attributes.*;
import lib.tools.codeGeneration.CodeBlock;
import lib.tools.codeGeneration.PCodeInstruction.OpCode;
import lib.tools.*;
import java.util.Stack;
import lib.tools.codeGeneration.PCodeInstruction;
import java.io.FileWriter;


public class adac_4 {

	static SymbolTable ts = new SymbolTable();
	
	static SemanticFunctions semFuncs = new SemanticFunctions();

	static Stack<Symbol> stack = new Stack<Symbol>();
	
	static SymbolProcedure principal;

	static FileWriter f = null;

    public static void main(String[] args) {
    	adac_4 parser;
		
		try{
			// fichero de generación de código
			f = new FileWriter(args[0].substring(0,args[0].lastIndexOf('.'))+".pcode"); 
			f.write("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
		} catch(IOException e) {
			System.out.println(e);
		}

    	try {
			
	    	if(args.length == 0) { //entrada desde stdin
				parser = new adac_4(System.in);
			}
			else { //entrada desde fichero en args[0]
	            parser = new adac_4(new java.io.FileInputStream(args[0])); 
			}
			parser.S(); //invoca símbolo inicial de la gramática
		}
		catch (java.io.FileNotFoundException e) {
			System.err.println ("Fichero " + args[0] + " no encontrado.");
		}
		catch (TokenMgrError e) {
        	System.err.println("LEX_ERROR: " + e.getMessage());
        }
        catch (ParseException e) {
        	System.err.println("SINT_ERROR: " + e.getMessage());
        }
		try{
			f.close();
		} catch(IOException e){
			System.err.println("ERROR CON EL FICHERO: " + e.getMessage());
		}
    }
}

PARSER_END(adac_4)
//------------ descripción del AL
SKIP:
{
	" "
|	"\t"
|	"\n"
	
}
//---------------------------------------------------------
TOKEN_MGR_DECLS : {
	//lo declarado aquí estará en "ejemploTokenManager"
	//también estará, por ejemplo, "lengthOfMatch", "image", ...
	static int nPalInt = 0;
	static int valNums = 0;
	static void infoToken(String mensaje, Token token){
		System.out.println("(" + token.beginLine + "," + token.beginColumn + "): " + mensaje + " " + token.image);
	}
}

SPECIAL_TOKEN : {
	< tCOM: "--"(~["\n"])*"\n" >
}

TOKEN:
{
 	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >
|	< #ALNUM: (< LETTER > | < DIGIT >) >
}

TOKEN:
{
	< tPOPEN: "(" >
|	< tPCLOSE: ")" >	
|	< tC2 : "\"" >
|	< tC1 : "\'" >
|	< tCOMA : "," >
|	< tPC: ";" >
|	< tCORCHETEOPEN : "[">
|	< tCORCHETECLOSE : "]" >
|	< tNUM : (< DIGIT >)+ >

}

TOKEN:
{
 	< tBEGIN: "begin" >
|	< tBOOL: "boolean" >
|	< tCHAR: "character" >
| 	< tINT: "integer" >
|	< tFUNC: "function" >
|	< tPROC: "procedure" >
|	< tIS : "is" >
|	< tVAL :  "val" >
|	< tREF : "ref" >
|	< tRET : "return" >
|	< tINT2CHAR : "int2char" >
|	< tCHAR2INT : "char2int" >
| 	< tSkL : "skip_line" >
}

TOKEN:
{
	< tIF: "if" >
|	< tTHEN: "then" >
|	< tELSE: "else" >
|	< tEND: "end" >
|	< tWHILE: "while" >
|	< tDO: "do" >
}

TOKEN:
{
	< tASIG: ":=" >
|	< tPUTLINE: "put_line" >
|	< tPUT: "put" >
|	< tGET: "get" >
}

TOKEN: 
{
	< tAND: "and">
|	< tOR: "or">
|	< tNOT: "not" >
|	< tMAYEQ: ">=" >
|	< tMENEQ: "<=" >
|	< tEQ: "=" >
|	< tMAY: ">" >
|	< tMEN : "<" >
|	< tDIST : "<>" >
|	< tTRUE : "true" >
|	< tFALSE : "false" >
}

TOKEN: 
{
	< tSUM: "+">
|	< tRES: "-">
|	< tMUL: "*">
|	< tDIV: "div">	
|	< tMOD: "mod">
|	< tSTRING : "\"" ("\"\"")* (("\"\"")* (~["\""])*)* "\"" >
|	< tCARACTER : "\'" (~[])? "\'" >
}


TOKEN:
{
	< tID:  (< LETTER > | ("_"(< ALNUM >)+)+ ) ( < ALNUM > | "_"(< ALNUM >)+ )* >
}

SPECIAL_TOKEN : {
	< tERROR: ~[] >
		{
			System.out.println("ERROR LÉXICO: (" + matchedToken.beginLine + "," + matchedToken.beginColumn + "): símbolo no reconocido " + matchedToken.image);
		}
}

void S () : 
{

}
{
	prog()
	< EOF >
}

//------------ Símbolo inicial de la gramática.
void prog () : 
{
	Token t;
	CodeBlock codeOut = new CodeBlock();
	String s;
	Attributes at = new Attributes();
}
{
  	<tPROC>
		{
			codeOut.addInst(PCodeInstruction.OpCode.ENP,"L0");
		}
  	t = <tID>
		{
			
			principal = semFuncs.insertProcedureSymbolTabFirst(ts, t);
			at.lastLabel = 0;
			at.dir = 3;
		}
  	<tIS>
 	declaracion_variables(at)
  	declaracion_procs_funcs(at)
		{
			at.code.addLabel("L0");
		}
	bloque_sentencias(at)
		{
			codeOut.addBlock(at.code);
			codeOut.addInst(PCodeInstruction.OpCode.LVP);
			codeOut.encloseXMLTags(t.image);
			s = codeOut.toString();
			escribirCodigo(s);
			codeOut.clearBlock();
			System.err.println(ts.toString());
		}
}

// bloque de declaración de las variables del programa principal o de una función
void declaracion_variables(Attributes at):
{

	Attributes at1 = new Attributes();
	at1.dir = at.dir;
}
{
	( declaracion(at1) <tPC> )*
	{
		at1.code.encloseXMLTags("variable_declaration");
		at.code.addBlock(at1.code);
		at.dir = at1.dir;
	}
}

// declaración de una lista de variables del mismo tipo
void declaracion(Attributes at):
{
	Symbol s = null;
	Token t1;

}
{
	tipo_variable(at) 
	lista_vars(at)
}

// recoge el tipo de una variable en concreto
void tipo_variable(Attributes at):
{

}
{
	<tINT> 
		{
			at.type = Symbol.Types.INT;
		}
| 	<tCHAR> 
		{
			at.type = Symbol.Types.CHAR;
		}
| 	<tBOOL>
		{
			at.type = Symbol.Types.BOOL;
		}
}

// lista que contiene los identificadores de las variables de un tipo
void lista_vars(Attributes at):
{

}
{
	variable(at) ( <tCOMA> variable(at) )*

}

// identificador de una variable
void variable(Attributes at):
{
	Token t1, t2;	
}
{
	LOOKAHEAD(2)
	t1 = <tID> <tCORCHETEOPEN> t2 = <tNUM> <tCORCHETECLOSE>
		{
			semFuncs.insertArraySymbolTab(ts,t1,at,t2);
			at.dir = at.dir + Integer.parseInt(t2.image);
		}
| 	t1 = <tID>
		{
			semFuncs.insertVariableSymbolTab(ts,t1,at);
			at.dir ++;
		}
}

// bloque de declaración de procedimientos o funciones
void declaracion_procs_funcs(Attributes at):
{

}
{
	( declaracion_proc_func(at) )*
}


// declaración de un procedimiento o una variable
void declaracion_proc_func(Attributes at):
{

}
{

	declaracion_procedimientos(at)
|	declaracion_funciones(at)
	
}

// declaración de un procedimiento
void declaracion_procedimientos(Attributes at):
{
	// se informa a los bloques inferiores sobre, direcciones a ocupar, bloque y etiquetas
	Attributes at1 = new Attributes(), at2 = new Attributes(), at3 = new Attributes();
	at3.dir = 3;
	int n = at.lastLabel + 1, n2;
	CodeBlock code1 = new CodeBlock();
	CodeBlock code2 = new CodeBlock();
	at3.funcDirection = n;
}
{
	cabecera_procedimiento(at3)
		{
			code1.addLabel("L"+n);
			at.lastLabel ++;
			
			n2 = at.lastLabel + 1;
			at.lastLabel++;
			at1.lastLabel = at.lastLabel;
			code1.addBlock(at3.code);
			at3.code.clearBlock();
			code1.addInst(PCodeInstruction.OpCode.JMP, "L"+n2);
			
		} 
	declaracion_variables(at3)
		{
			code2.addBlock(at3.code);
			code1.addBlock(code2);
			code2.clearBlock();
			at1.dir = at3.dir;
		}
	(declaracion_proc_func(at1))*
		{
			code1.addBlock(at1.code);
			at.lastLabel = at1.lastLabel;
			at2.lastLabel = at1.lastLabel;
			at2.dir = at3.dir;
		}
	bloque_sentencias(at2)
		{
			code1.addLabel("L"+n2);
			code2.addBlock(at2.code);
			code2.addInst(PCodeInstruction.OpCode.CSF);
			code2.encloseXMLTags("instruction_block");
			code1.addBlock(code2);
			code1.encloseXMLTags("procedure");
			at.code.addBlock(code1);
			ts.removeBlock();
			stack.pop();
			at.lastLabel = at2.lastLabel;
		}
}

// declaración de una función
void declaracion_funciones(Attributes at):
{
	// se informa a los bloques inferiores sobre, direcciones a ocupar, bloque y etiquetas
	Attributes at1 = new Attributes(), at2 = new Attributes(), at3 = new Attributes();
	at3.dir = 3;
	int n = at.lastLabel + 1, n2;
	CodeBlock code1 = new CodeBlock();
	CodeBlock code2 = new CodeBlock();
	at3.funcDirection = n;
}
{
	cabecera_funcion(at3) 
		{
			code1.addLabel("L"+n);
			at.lastLabel ++;
			
			n2 = at.lastLabel + 1;
			at.lastLabel++;
			at1.lastLabel = at.lastLabel;
			code1.addBlock(at3.code);
			at3.code.clearBlock();
			code1.addInst(PCodeInstruction.OpCode.JMP, "L"+n2);		
		}
	declaracion_variables(at3)
		{
			code2.addBlock(at3.code);
			code1.addBlock(code2);
			code2.clearBlock();
			at1.dir = at3.dir;
		}
	(declaracion_proc_func(at1))* 
		{
			code1.addBlock(at1.code);
			at.lastLabel = at1.lastLabel;
			at2.lastLabel = at.lastLabel;
			at2.dir = at3.dir;
		}
	bloque_sentencias(at2)
		{
			
			code1.addLabel("L"+n2);
			code2.addBlock(at2.code);
			code2.addInst(PCodeInstruction.OpCode.CSF);
			code2.encloseXMLTags("instruction_block");
			code1.addBlock(code2);
			code1.encloseXMLTags("procedure");
			at.code.addBlock(code1);
			ts.removeBlock();
			stack.pop();
			at.lastLabel = at2.lastLabel;			
		}
}

// cabecera de un procedimiento. Se tratan los argumentos según sean por valor o por referencia, y según sean o no de tipo ARRAY
void cabecera_procedimiento(Attributes at):
{
	Token t;
	SymbolProcedure sp;
	CodeBlock code1 = new CodeBlock();
	int n;
	SymbolArray sa;
}
{
	<tPROC> t = <tID> 
		{
			semFuncs.insertProcedureSymbolTab(ts,t, at.funcDirection);
			sp = (SymbolProcedure)ts.getSymbol(t.image);
			stack.push(ts.getSymbol(t.image));
			at.token = t;
			at.type = Symbol.Types.PROCEDURE;
		}
	<tPOPEN> lista_parametros(at) <tPCLOSE> <tIS>
		{
			
			for(int i = sp.parList.size()-1; i >= 0; i--){
				Symbol s = sp.parList.get(i);
				if(s.type != Symbol.Types.ARRAY){
					n = i+1;
					code1.addComment(" Recover simple val / ref variable parameter \"" + s.name + "\" (number " + n + ")" );
					if(s.parClass == Symbol.ParameterClass.VAL){
						code1.addInst(PCodeInstruction.OpCode.SRF, stack.size()-s.nivel, (int)s.dir);
						code1.addInst(PCodeInstruction.OpCode.ASGI);
						code1.encloseXMLTags("recover_argument_"+n);
						at.code.addBlock(code1);
						code1.clearBlock();
					} else if(s.parClass == Symbol.ParameterClass.REF){
						code1.addInst(PCodeInstruction.OpCode.SRF, stack.size()-s.nivel, (int)s.dir);
						code1.addInst(PCodeInstruction.OpCode.ASGI);
						code1.encloseXMLTags("recover_argument_"+n);
						at.code.addBlock(code1);
						code1.clearBlock();
					}
				} else {
					n = i+1;
					if(s.parClass == Symbol.ParameterClass.VAL){
						code1.addComment("  Recover array val variable parameter \""+ s.name + "\" (number "+ n +")");
						sa = (SymbolArray)s;
						for(int j = sa.maxInd; j >= 0; j--){
							code1.addInst(PCodeInstruction.OpCode.SRF, stack.size()-s.nivel, (int)s.dir+j);
							code1.addInst(PCodeInstruction.OpCode.ASGI);
							
						}
						code1.encloseXMLTags("recover_argument_"+n);
						at.code.addBlock(code1);
						code1.clearBlock();
					} else {
						code1.addInst(PCodeInstruction.OpCode.SRF, stack.size()-s.nivel, (int)s.dir);
						code1.addInst(PCodeInstruction.OpCode.ASGI);
						code1.encloseXMLTags("recover_argument_"+n);
						at.code.addBlock(code1);
						code1.clearBlock();
					}
				}
			}
		}
		
}

// cabecera de una función. Se tratan los argumentos según sean por valor o por referencia, y según sean o no de tipo ARRAY
void cabecera_funcion(Attributes at):
{
	Token t;
	Symbol.Types tipo;
	SymbolFunction sp;
	int n;
	CodeBlock code1 = new CodeBlock();
	SymbolArray sa;
}
{
	// contiene el tipo base de la función, el nombre de la misma y su declaración de parámetros
	<tFUNC> tipo_variable(at) t = <tID>
		{
			
			semFuncs.insertFunctionSymbolTab(ts,t,at,at.funcDirection);
			sp = (SymbolFunction)ts.getSymbol(t.image);
			stack.push(ts.getSymbol(t.image));
			at.token = t;
			at.type = Symbol.Types.FUNCTION;
		}
	<tPOPEN> lista_parametros(at) <tPCLOSE> <tIS>
		{
			
			for(int i = sp.parList.size()-1; i >= 0; i--){
				Symbol s = sp.parList.get(i);
				if(s.type != Symbol.Types.ARRAY){
					n = i+1;
					code1.addComment(" Recover simple val / ref variable parameter \"" + s.name + "\" (number " + n + ")" );
					if(s.parClass == Symbol.ParameterClass.VAL){
						code1.addInst(PCodeInstruction.OpCode.SRF, stack.size()-s.nivel, (int)s.dir);
						code1.addInst(PCodeInstruction.OpCode.ASGI);
						code1.encloseXMLTags("recover_argument_"+n);
						at.code.addBlock(code1);
						code1.clearBlock();
					} else if(s.parClass == Symbol.ParameterClass.REF) {
						code1.addInst(PCodeInstruction.OpCode.SRF, stack.size()-s.nivel, (int)s.dir);
						code1.addInst(PCodeInstruction.OpCode.ASGI);
						code1.encloseXMLTags("recover_argument_"+n);
						at.code.addBlock(code1);
						code1.clearBlock();
					}
				} else {
					n = i+1;
					if(s.parClass == Symbol.ParameterClass.VAL){
						code1.addComment("  Recover array val variable parameter \""+ s.name + "\" (number "+ n +")");
						sa = (SymbolArray)s;
						for(int j = sa.maxInd; j >= 0; j--){
							code1.addInst(PCodeInstruction.OpCode.SRF, stack.size()-s.nivel, (int)s.dir+j);
							code1.addInst(PCodeInstruction.OpCode.ASGI);
						}
						code1.encloseXMLTags("recover_argument_"+n);
						at.code.addBlock(code1);
						code1.clearBlock();
					} else {
						code1.addComment("  Recover array ref variable parameter \""+ s.name + "\" (number "+ n +")");
						code1.addInst(PCodeInstruction.OpCode.SRF, stack.size()-s.nivel, (int)s.dir);
						code1.addInst(PCodeInstruction.OpCode.ASGI);
						code1.encloseXMLTags("recover_argument_"+n);
						at.code.addBlock(code1);
						code1.clearBlock();
					}
				}
			}
		}
		
}

// lista de parámetros de un procedimiento o una función.
// contiene 0 o más parámetros
void lista_parametros(Attributes at):
{

}
{
	(parametro(at) (<tPC> parametro(at))*)?
}

// parametro de una función o procedimiento.
// Se indica si es pasado por valor o por referencia, el tipo de parámetros y los identificadores que corresponden a tal definición
void parametro(Attributes at):
{
	Symbol.Types tipo;
	Attributes at1 = new Attributes();
	Token t;
}
{
	( <tVAL>
		{
			semFuncs.insertParameterType(at1,Symbol.ParameterClass.VAL);
		} 
	| <tREF>
		{
			semFuncs.insertParameterType(at1,Symbol.ParameterClass.REF);
		})
	
 
	tipo_variable(at1) lista_parametros_formales(at,at1)
}

// lista de parámetros del mismo tipo de una función o procedimiento
void lista_parametros_formales(Attributes at, Attributes at1):
{

}
{
	parametro_formal(at,at1) ( <tCOMA> parametro_formal(at,at1) )*
}

// parámetro de la cabecera de un procedimiento o función de un determinado tipo
void parametro_formal(Attributes at, Attributes at1):
{
	Token t1, t2;
}
{
	LOOKAHEAD(2)
	t1 = <tID> <tCORCHETEOPEN> t2 = <tNUM> <tCORCHETECLOSE>
		{
			semFuncs.insertVector(ts,t1,t2,at,at1);
		}
| 	t1 = <tID>
		{
			semFuncs.insertParametro(ts,at,at1,t1);
		}
}

// bloque de instrucciones de código
void bloque_sentencias(Attributes at):
{
	
}
{
	try {
		<tBEGIN>
		(inst(at))*
		<tEND>
	} catch (ParseException e){
		Set<Integer> conjSinc = infoParseException(e);
		conjSinc.add(tEND);
		recuperacionPanico(e.currentToken.next,conjSinc);
	}
}

// instrucción. Pueden ser también sentencias if-else o while
void inst(Attributes at):
{
	// información de si hay instrucciones para realizar optimizaciónes de código
	at.hayAlgo = true;
}
{
	inst_acaban_pc(at) 
|	inst_acaban_end(at)
}

// instrucciones accabadas en punto y coma
void inst_acaban_pc(Attributes at):
{

}
{
	try {
		(inst_leer(at)
		|	inst_saltar_linea(at)
		|	inst_escribir(at)
		|	inst_escribir_linea(at)
		|	LOOKAHEAD(2) inst_invoc_proc(at)
		|	inst_asignacion(at)
		|	inst_return(at)
		)
			<tPC>
			
	} catch(ParseException e){
		Set<Integer> conjSinc = infoParseException(e);
		conjSinc.add(tPC);
		recuperacionPanico(e.currentToken.next,conjSinc);
	}
}

// instrucciones que acaban en la sentencia end
void inst_acaban_end(Attributes at):
{
}
{
	try{
		(inst_iteracion(at)
	|	inst_seleccion(at) ) <tEND>
			
	} catch(ParseException e){
		Set<Integer> conjSinc = infoParseException(e);
		conjSinc.add(tEND);
		recuperacionPanico(e.currentToken.next,conjSinc);
	}
}

// instrucciones de asignación
void inst_asignacion(Attributes at):
{
	Attributes at1 = new Attributes(), at2 = new Attributes();
	CodeBlock codeOut = new CodeBlock();
	Symbol s;
	at2.dir = at.dir;
	at1.dir = at.dir;
}
{
	asignable(at1)
	<tASIG>
	expresion(at2)
		{
			semFuncs.checkAsignacion(at1,at2);
			codeOut.addBlock(at1.code);
			codeOut.addBlock(at2.code);
			if(!at2.constante) codeOut.addInst(PCodeInstruction.OpCode.DRF);
			if(at2.parClass != null && at2.parClass == Symbol.ParameterClass.REF) codeOut.addInst(PCodeInstruction.OpCode.DRF);
			codeOut.addInst(PCodeInstruction.OpCode.ASG);
			codeOut.encloseXMLTags("Asignacion_a_variable_simple_"+at1.token.image);
			at.code.addBlock(codeOut);
		}
}

// asignable, se busca el identifiador de la variable a la que se quiere asignar algo
void asignable(Attributes at):
{
	Attributes at1 = new Attributes();
	Token t;
	Symbol s;
	at1.dir = at.dir;
}
{
	LOOKAHEAD(2)
	t = <tID> <tCORCHETEOPEN> expresion(at1) <tCORCHETECLOSE>
		{
			semFuncs.checkAsignable(ts,t,at1,at);
			s = ts.getSymbol(t.image);
			at.code.addBlock(at1.code);
			if(!at1.constante) at.code.addInst(PCodeInstruction.OpCode.DRF);
			if(at1.parClass != null && at1.parClass == Symbol.ParameterClass.REF) at.code.addInst(PCodeInstruction.OpCode.DRF);
			at.code.addComment(" Initial address of array \"" + t.image +"\"");
			at.code.addInst(PCodeInstruction.OpCode.SRF,stack.size()-s.nivel,(int)s.dir);
			if(s.parClass == Symbol.ParameterClass.REF) at.code.addInst(PCodeInstruction.OpCode.DRF);
			
			at.code.addInst(PCodeInstruction.OpCode.PLUS);
		}
| 	t = <tID>
		{
			semFuncs.checkAsignable(ts,t,at);
			s = ts.getSymbol(t.image);
			at.code.addComment(" Address of variable / parameter \"" + t.image +"\"");
			at.code.addInst(PCodeInstruction.OpCode.SRF,stack.size()-s.nivel,(int)s.dir);
			if(s.parClass == Symbol.ParameterClass.REF) at.code.addInst(PCodeInstruction.OpCode.DRF);
		}
		
}

// instrucción de bucle while
void inst_iteracion(Attributes at):
{
	Attributes at1 = new Attributes(), at2 = new Attributes();
	CodeBlock codeOut = new CodeBlock();
	int n = at.lastLabel + 1,n2;
	at.lastLabel++;
	n2 = at.lastLabel+1;
	at.lastLabel++;
	at1.dir = at.dir;
	at2.dir = at.dir;
	CodeBlock code2 = new CodeBlock();
}
{
	<tWHILE>
	expresion(at1)
		{
			semFuncs.checkBool(at1);
			codeOut.addInst(PCodeInstruction.OpCode.JMP,"L"+n);			
			
			at2.lastLabel = at.lastLabel;
			at2.dir = at.dir;
		}
	<tDO>
	(inst(at2))*
		{	
			at.lastLabel = at2.lastLabel;

			code2.addLabel("L"+n2);
			code2.addBlock(at2.code);
			code2.encloseXMLTags("while_instruction_block");
			codeOut.addBlock(code2);
			code2.clearBlock();
			
			codeOut.addLabel("L"+n);
			code2.addBlock(at1.code);
			if(!at1.constante) code2.addInst(PCodeInstruction.OpCode.DRF);
			code2.encloseXMLTags("condition");
			if(at1.parClass != null && at1.parClass == Symbol.ParameterClass.REF) code2.addInst(PCodeInstruction.OpCode.DRF);
			code2.addInst(PCodeInstruction.OpCode.JMT, "L"+n2);
			codeOut.addBlock(code2);
			code2.clearBlock();

			codeOut.encloseXMLTags("while");
			at.code.addBlock(codeOut);
		}
}

// instrucción de return
void inst_return(Attributes at):
{
	Attributes at1 = new Attributes();
	at1.dir = at.dir;
	Symbol s;
	SymbolFunction sf = new SymbolFunction("",null,null);
	Token t;
	CodeBlock code1 = new CodeBlock();
}
{
	t = <tRET>	expresion(at1)
		{
			semFuncs.checkFunction(stack, at1);
			code1.addBlock(at1.code);
			if(!at1.constante) code1.addInst(PCodeInstruction.OpCode.DRF);
			if(at1.parClass != null && at1.parClass == Symbol.ParameterClass.REF) code1.addInst(PCodeInstruction.OpCode.DRF);
			code1.addInst(PCodeInstruction.OpCode.CSF);
			code1.encloseXMLTags("return");
			at.code.addBlock(code1);
		}
}

// instrucción de lectura por la entrada estándar
void inst_leer(Attributes at):
{
	Attributes at1 = new Attributes(), at2 = new Attributes();
	CodeBlock codeOut = new CodeBlock();
	at1.dir = at.dir;
}
{
	try {
		<tGET> <tPOPEN> lista_asignables(at1) <tPCLOSE>
			{
				for(Attributes a : at1.par){
					codeOut.addBlock(a.code);
					codeOut.addInst(PCodeInstruction.OpCode.RD,(a.type==Symbol.Types.CHAR)?0:1);
				}
				at.code.addBlock(codeOut);
			}
	} catch(ParseException e){
		Set<Integer> conjSinc = infoParseException(e);
		conjSinc.add(tPCLOSE);
		recuperacionPanico(e.currentToken.next,conjSinc);
	}
}

// lista de variables que se pueden asignar
void lista_asignables(Attributes at):
{
	Attributes at1 = new Attributes(), at2 = new Attributes();
	at1.dir = at.dir;
	at2.dir = at.dir;
}
{
	asignable(at1) (<tCOMA> lista_asignables(at2))?
		{
			semFuncs.checkAsignableGet(at1);
			at.par.add(at1);
			at.par.addAll(at2.par);
		}
}

// instrucción de escribir por la salida estándar
void inst_escribir(Attributes at):
{
	Attributes at1 = new Attributes();
	at1.dir = at.dir;
	CodeBlock codeOut = new CodeBlock();
}
{
    try {
		<tPUT> <tPOPEN> lista_una_o_mas_exps(at1)
    	<tPCLOSE>
		{
			try{
				codeOut.clearBlock();
				for(Attributes a : at1.par){
					
					if(a.type == Symbol.Types.STRING){
						if(!a.constante) a.code.addInst(PCodeInstruction.OpCode.DRF);
						if(a.parClass != null && a.parClass == Symbol.ParameterClass.REF) a.code.addInst(PCodeInstruction.OpCode.DRF);
						a.code.encloseXMLTags("put");
						codeOut.addComment(" Put STRING");
						codeOut.addBlock(a.code);
					} else if(a.type == Symbol.Types.INT){
						if(!a.constante) a.code.addInst(PCodeInstruction.OpCode.DRF);
						if(a.parClass != null && a.parClass == Symbol.ParameterClass.REF) a.code.addInst(PCodeInstruction.OpCode.DRF);
						a.code.addComment(" Put INTEGER");
						a.code.addInst(PCodeInstruction.OpCode.WRT,1);
						a.code.encloseXMLTags("put");
						codeOut.addBlock(a.code);
					} else if(a.type == Symbol.Types.CHAR){
						if(!a.constante) a.code.addInst(PCodeInstruction.OpCode.DRF);
						if(a.parClass != null && a.parClass == Symbol.ParameterClass.REF) a.code.addInst(PCodeInstruction.OpCode.DRF);
						a.code.addComment(" Put CHAR");
						a.code.addInst(PCodeInstruction.OpCode.WRT,0);
						a.code.encloseXMLTags("put");
						codeOut.addBlock(a.code);
					} else if(a.type == Symbol.Types.BOOL){
						if(!a.constante) a.code.addInst(PCodeInstruction.OpCode.DRF);
						if(a.parClass != null && a.parClass == Symbol.ParameterClass.REF) a.code.addInst(PCodeInstruction.OpCode.DRF);
						a.code.addComment(" Put BOOL");
						a.code.addInst(PCodeInstruction.OpCode.WRT,1);
						a.code.encloseXMLTags("put");
						codeOut.addBlock(a.code);
					}
				}
				codeOut.encloseXMLTags("put");
				at.code.addBlock(codeOut);
			} catch(Exception e){
				System.err.println("Excepción: " + e.getMessage());
			}
		}
	} catch(ParseException e){
		Set<Integer> conjSinc = infoParseException(e);
		conjSinc.add(tPCLOSE);
		recuperacionPanico(e.currentToken.next,conjSinc);
	}
}

// instrucción de escribir una linea por la salida estándar
void inst_escribir_linea(Attributes at):
{
	Attributes at1 = new Attributes();
	CodeBlock codeOut = new CodeBlock();
	at1.dir = at.dir;
}
{
    try {
		<tPUTLINE> <tPOPEN> (lista_una_o_mas_exps(at1))?
    	<tPCLOSE>
		{
			try{
				for(Attributes a : at1.par){
					
					
					if(a.type == Symbol.Types.STRING){
						if(!a.constante) a.code.addInst(PCodeInstruction.OpCode.DRF);
						if(a.parClass != null && a.parClass == Symbol.ParameterClass.REF && a.type != Symbol.Types.ARRAY) a.code.addInst(PCodeInstruction.OpCode.DRF);
						a.code.encloseXMLTags("put");
						codeOut.addComment(" Put STRING");
						codeOut.addBlock(a.code);
						
					} else if(a.type == Symbol.Types.INT){
						if(!a.constante) a.code.addInst(PCodeInstruction.OpCode.DRF);
						if(a.parClass != null && a.parClass == Symbol.ParameterClass.REF && a.type != Symbol.Types.ARRAY) a.code.addInst(PCodeInstruction.OpCode.DRF);
						a.code.addComment(" Put INTEGER");
						a.code.addInst(PCodeInstruction.OpCode.WRT,1);
						a.code.encloseXMLTags("put");
						codeOut.addBlock(a.code);
						
					} else if(a.type == Symbol.Types.CHAR){
						if(!a.constante) a.code.addInst(PCodeInstruction.OpCode.DRF);
						if(a.parClass != null && a.parClass == Symbol.ParameterClass.REF && a.type != Symbol.Types.ARRAY) a.code.addInst(PCodeInstruction.OpCode.DRF);
						a.code.addComment(" Put CHAR");
						a.code.addInst(PCodeInstruction.OpCode.WRT,0);
						a.code.encloseXMLTags("put");
						codeOut.addBlock(a.code);
						
					} else if(a.type == Symbol.Types.BOOL){	
						if(!a.constante) a.code.addInst(PCodeInstruction.OpCode.DRF);
						if(a.parClass != null && a.parClass == Symbol.ParameterClass.REF && a.type != Symbol.Types.ARRAY) a.code.addInst(PCodeInstruction.OpCode.DRF);		
						a.code.addComment(" Put BOOL");
						a.code.addInst(PCodeInstruction.OpCode.WRT,1);
						a.code.encloseXMLTags("put");
						codeOut.addBlock(a.code);
						
					}
				}
				codeOut.addComment(" CR/LF");
				codeOut.addInst(PCodeInstruction.OpCode.STC,13);
				codeOut.addInst(PCodeInstruction.OpCode.WRT,0);
				codeOut.addInst(PCodeInstruction.OpCode.STC,10);
				codeOut.addInst(PCodeInstruction.OpCode.WRT,0);
				codeOut.encloseXMLTags("put_line");
				at.code.addBlock(codeOut);
			} catch(Exception e){
				System.err.println("Excepción: " + e.getMessage());
			}
		}
	} catch(ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		conjSinc.add(tPCLOSE);
		recuperacionPanico(e.currentToken.next,conjSinc);
	}
}

// invocación a un procedimiento
void inst_invoc_proc(Attributes at):
{
	Attributes at1 = new Attributes();
	Token t;
	Symbol s;
	CodeBlock code1 = new CodeBlock();
	CodeBlock code2 = new CodeBlock();	
	SymbolProcedure sp;
	Attributes at2;
	SymbolArray sa;
	int i,n;
	at1.dir = at.dir;
}
{
    try {
		t = <tID> <tPOPEN> (lista_una_o_mas_exps(at1))? <tPCLOSE>
			{
				semFuncs.comprobarNoPrincipal(principal,t);
				semFuncs.comprobacionParametros(at1,t,ts);
				s = ts.getSymbol(t.image);
				
				sp = (SymbolProcedure)s;
				i = 0;
				n = 0;
				for(Symbol s1 : sp.parList){
					if(s1.parClass == Symbol.ParameterClass.VAL){
						at2 = at1.par.get(i);
						if(at2.type == Symbol.Types.ARRAY){
							sa = (SymbolArray) ts.getSymbol(at2.token.image);
							code2.addComment(" Variable / parameter \"" + at2.token.image + "\"");
							if(sa.parClass == Symbol.ParameterClass.REF){
								for(int j = sa.minInd; j <= sa.maxInd; j ++){
									code2.addInst(PCodeInstruction.OpCode.SRF, stack.size()-sa.nivel, (int)sa.dir);
									code2.addInst(PCodeInstruction.OpCode.DRF);
									code2.addInst(PCodeInstruction.OpCode.STC,j);
									code2.addInst(PCodeInstruction.OpCode.PLUS);
									code2.addInst(PCodeInstruction.OpCode.DRF);
								}
								n = i+1;
								code2.encloseXMLTags("argument_"+n);
								code1.addBlock(code2);
								code2.clearBlock();
							} else{
								for(int j = sa.minInd; j <= sa.maxInd; j ++){
									code2.addInst(PCodeInstruction.OpCode.SRF, stack.size()-sa.nivel, (int)sa.dir+j);
									code2.addInst(PCodeInstruction.OpCode.DRF);
								}
								n = i+1;
								code2.encloseXMLTags("argument_"+n);
								code1.addBlock(code2);
								code2.clearBlock();
							}
						} else {
							code2.addBlock(at2.code);
							if(!at2.constante) code2.addInst(PCodeInstruction.OpCode.DRF);
							if(at2.parClass != null && at2.parClass == Symbol.ParameterClass.REF) code2.addInst(PCodeInstruction.OpCode.DRF);
							n = i+1;
							code2.encloseXMLTags("argument_"+n);
							code1.addBlock(code2);
							code2.clearBlock();
						}
					} else if(s1.parClass == Symbol.ParameterClass.REF){
						
						at2 = at1.par.get(i);
						code2.addBlock(at2.code);
						if(at2.parClass != null && at2.parClass == Symbol.ParameterClass.REF && !at2.constante) code2.addInst(PCodeInstruction.OpCode.DRF);
						n = i+1;
						code2.encloseXMLTags("argument_"+n);
						code1.addBlock(code2);
						code2.clearBlock();
					}
					
					i++;
				}

				code1.addOSFInst((int)at.dir,stack.size()-s.nivel,"L"+s.dir);
				code1.encloseXMLTags("procedure_call_"+t.image);
				at.code.addBlock(code1);
			}
	} catch (ParseException e){
		Set<Integer> conjSinc = infoParseException(e);
		conjSinc.add(tPCLOSE);
		recuperacionPanico(e.currentToken.next,conjSinc);
	}
}

// instrucción <if-then>
void inst_seleccion(Attributes at):
{
	Attributes at1 = new Attributes(), at2 = new Attributes(), at3 = new Attributes();
	int n = at.lastLabel +1,n2;
	CodeBlock codeOut = new CodeBlock();
	at1.dir = at.dir;
	at1.lastLabel = at.lastLabel;
	CodeBlock code2 = new CodeBlock();
	boolean hayElse = false;
	Token t;
}
{
	
	<tIF> 
	expresion(at1) 
		{
			semFuncs.checkBool(at1);
			
			at1.lastLabel = at.lastLabel;
			at1.dir = at.dir;
			codeOut.addBlock(at1.code);
			if(!at1.constante) codeOut.addInst(PCodeInstruction.OpCode.DRF);
			codeOut.encloseXMLTags("condition");
			if(at1.parClass != null && at1.parClass == Symbol.ParameterClass.REF) codeOut.addInst(PCodeInstruction.OpCode.DRF);
			n = at.lastLabel +1;
			codeOut.addInst(PCodeInstruction.OpCode.JMF, "L"+n);
			code2.addBlock(codeOut);
			at.lastLabel++;
			at2.lastLabel = at.lastLabel;
			at2.dir = at.dir;
		}
	<tTHEN> (inst(at2))*
	{
		codeOut.clearBlock();
		codeOut.addBlock(at2.code);
		n2 = at2.lastLabel + 1;
		at.lastLabel = at2.lastLabel+1;
		
		at3.lastLabel = at.lastLabel;
		at3.dir = at.dir;
		at3.hayAlgo = false;
	}
	(<tELSE> (inst(at3))* )? 
	{
		at.lastLabel = at3.lastLabel;
		if(at3.hayAlgo){
			codeOut.addInst(PCodeInstruction.OpCode.JMP, "L"+n2);
		} else {
			at.lastLabel --;
		}
		codeOut.encloseXMLTags("then");
		code2.addBlock(codeOut);
		codeOut.clearBlock();
		codeOut.addLabel("L"+n);
		if(at3.hayAlgo){
			codeOut.addBlock(at3.code);
			codeOut.encloseXMLTags("else");
			codeOut.addLabel("L"+n2);
		}
		code2.addBlock(codeOut);
		code2.encloseXMLTags("if-then");
		at.code.addBlock(code2);
		
	}
}

// saltar caracteres de la entrada estándar hasta la llegada de un salto de linea
void inst_saltar_linea(Attributes at):
{
	CodeBlock code1 = new CodeBlock();
	int n = at.lastLabel + 1;
	at.lastLabel++;
}
{
	try {
		<tSkL> <tPOPEN> <tPCLOSE>
			{
				code1.addLabel("L"+n);
				code1.addComment(" Temporary hidden compiler variable used for reading until LF");
				code1.addInst(PCodeInstruction.OpCode.SRF,0,(int)at.dir);
				code1.addInst(PCodeInstruction.OpCode.RD,0);
				code1.addInst(PCodeInstruction.OpCode.SRF,0,(int)at.dir);
				code1.addInst(PCodeInstruction.OpCode.DRF);
				code1.addInst(PCodeInstruction.OpCode.STC,10);
				code1.addInst(PCodeInstruction.OpCode.EQ);
				code1.addInst(PCodeInstruction.OpCode.JMF,"L"+n);
				code1.encloseXMLTags("skip_line");
				at.code.addBlock(code1);
			}
	} catch (ParseException e){
		Set<Integer> conjSinc = infoParseException(e);
		conjSinc.add(tPCLOSE);
		recuperacionPanico(e.currentToken.next,conjSinc);
	}
}

// lista de una o más expresiones, separadas por comas
void lista_una_o_mas_exps(Attributes at):
{
	Attributes at1 = new Attributes(), at2 = new Attributes(), at3 = new Attributes();
	at1.dir = at.dir;
	at2.dir = at.dir;
}
{
	expresion(at1) (at3.token = <tCOMA> lista_una_o_mas_exps(at2))?
		{
			semFuncs.saveInfoParameter(at,at1,at2);
		}
}

// expresión
void expresion(Attributes at):
{
	Attributes at1 = new Attributes(), at2 = new Attributes(), at3 = new Attributes();
	at1.dir = at.dir;
	at2.dir = at.dir;
}
{
	expresion_simple(at1) ( operador_relacional(at3) expresion_simple(at2) )?
		{
			semFuncs.check2typesWithRelationalOperator(at1, at2, at3, at);
		}
}

// operador lógico relacional
void operador_relacional(Attributes at):
{
	Token t;
}
{
	t = <tEQ>
		{
			at.token = t;
			at.code.addInst(PCodeInstruction.OpCode.EQ);
		}
|	t = <tMAYEQ>
		{
			at.token = t;
			at.code.addInst(PCodeInstruction.OpCode.GTE);
		}
|	t = <tMENEQ>
		{
			at.token = t;
			at.code.addInst(PCodeInstruction.OpCode.LTE);
		}
|	t = <tMAY>
		{
			at.token = t;
			at.code.addInst(PCodeInstruction.OpCode.GT);
		}
|	t = <tMEN>
		{
			at.token = t;
			at.code.addInst(PCodeInstruction.OpCode.LT);
		}
|	t = <tDIST>
		{
			at.token = t;
			at.code.addInst(PCodeInstruction.OpCode.NEQ);
		}
}

// expresión simple
void expresion_simple(Attributes at):
{
	Attributes at1 = new Attributes(), at2 = new Attributes(), at3 = new Attributes();
	at1.dir = at.dir;
	at2.dir = at.dir;
	Token t = new Token();
}
{
	(t = <tRES> | <tSUM>)?
		
	termino(at1) 
		{
			if(t.image != null){
				at1.code.addInst(PCodeInstruction.OpCode.NGI);
			}
			at.type = at1.type;
			at.token = at1.token;
			at.constante = at1.constante;
			at.dimension = at1.dimension;
			at.parClass = at1.parClass;
			at.code.addBlock(at1.code);
		}
	(exp_simpl2(at1,at))?
		
}

// función auxiliar para la implementación de recursividad por la izquierda
void exp_simpl2(Attributes at1, Attributes at):
{
	Attributes at2 = new Attributes(), at3 = new Attributes(), at4 = new Attributes();
	at2.dir = at.dir;
	Token t = new Token();
	CodeBlock code1 = new CodeBlock();
}
{
	operador_aditivo(at3) termino(at2) 
	
		{
			semFuncs.check2typesWithOperator(at1,at2,at3,at);
			if(!at1.constante) at.code.addInst(OpCode.DRF);
			if(at1.parClass != null && at1.parClass == Symbol.ParameterClass.REF) at.code.addInst(OpCode.DRF);
			at.code.addBlock(at2.code);
			if(!at2.constante) at.code.addInst(OpCode.DRF);
			if(at2.parClass != null && at2.parClass == Symbol.ParameterClass.REF) at.code.addInst(OpCode.DRF);
			at.code.addBlock(at3.code);
			at2.constante = true;
			at2.parClass = Symbol.ParameterClass.NONE;
			at.parClass = Symbol.ParameterClass.NONE;
		}
		(exp_simpl2(at2,at))?
}

// operadores aditivos
void operador_aditivo(Attributes at):
{
	Token t;
}
{
	t = <tSUM>
		{
			at.type = Symbol.Types.INT;
			at.token = t;
			at.code.addInst(PCodeInstruction.OpCode.PLUS);
		}
|	t = <tRES>
		{
			at.type = Symbol.Types.INT;
			at.token = t;
			at.code.addInst(PCodeInstruction.OpCode.SBT);
		}
| 	t = <tOR>
		{
			at.type = Symbol.Types.BOOL;
			at.token = t;
			at.code.addInst(PCodeInstruction.OpCode.OR);
		}
}

// termino
void termino(Attributes at):
{
	Attributes at1 = new Attributes(), at2 = new Attributes(), at3 = new Attributes();
	Token t;
	at1.dir = at.dir;
	at2.dir = at.dir;
	Symbol.Types expected;
}
{
	factor(at1)
		{
			at.type = at1.type;
			at.token = at1.token;
			at.constante = at1.constante;
			at.dimension = at1.dimension;
			at.parClass = at1.parClass;
			at.code.addBlock(at1.code);
		}	
	(termino2(at1,at))?
}

// función auxiliar para realizar la recursividad por la izquierda
void termino2(Attributes at1, Attributes at):
{
	Attributes at2 = new Attributes(), at3 = new Attributes(), at4 = new Attributes();
	at1.dir = at.dir;
	at2.dir = at.dir;
	Token t = new Token();
	CodeBlock code1 = new CodeBlock();
}
{
	
	operador_multiplicativo(at3) factor(at2)
		{
			semFuncs.check2typesWithOperator(at1,at2,at3,at);
			if(!at1.constante) at.code.addInst(OpCode.DRF);
			if(at1.parClass != null && at1.parClass == Symbol.ParameterClass.REF) at.code.addInst(OpCode.DRF);
			at.code.addBlock(at2.code);
			if(!at2.constante) at.code.addInst(OpCode.DRF);
			if(at2.parClass != null && at2.parClass == Symbol.ParameterClass.REF) at.code.addInst(OpCode.DRF);
			at.code.addBlock(at3.code);
			at2.constante = true;
			at2.parClass = Symbol.ParameterClass.NONE;
			at.parClass = Symbol.ParameterClass.NONE;
		}
	(termino2(at2,at))?
}
	
// operador multiplicativo
void operador_multiplicativo(Attributes at):
{
	Token t;
}
{
	t = <tMUL>
		{
			at.type = Symbol.Types.INT;
			at.token = t;
			at.code.addInst(PCodeInstruction.OpCode.TMS);
		}
|	t = <tMOD>
		{
			at.type = Symbol.Types.INT;
			at.token = t;
			at.code.addInst(PCodeInstruction.OpCode.MOD);
		}
|	t = <tDIV>
		{
			at.type = Symbol.Types.INT;
			at.token = t;
			at.code.addInst(PCodeInstruction.OpCode.DIV);
		}
|	t = <tAND>
		{
			at.type = Symbol.Types.BOOL;
			at.token = t;
			at.code.addInst(PCodeInstruction.OpCode.AND);
		}
}

// factor
void factor(Attributes at):
{
	Token t;
	Symbol s;
	Symbol.Types tipo;
}
{
	 
	<tNOT> factor(at)
		{
			semFuncs.checkBool(at);
			if(!at.constante) at.code.addInst(PCodeInstruction.OpCode.DRF);
			if(at.parClass != null && at.parClass == Symbol.ParameterClass.REF) at.code.addInst(PCodeInstruction.OpCode.DRF);
			at.constante = true;
			at.code.addInst(PCodeInstruction.OpCode.NGB);
			at.parClass = Symbol.ParameterClass.NONE;
		}
|	<tPOPEN> expresion(at) <tPCLOSE>
| 	LOOKAHEAD(2) factor_con_par(at)
|	LOOKAHEAD(2) t = <tID> <tCORCHETEOPEN> expresion(at) <tCORCHETECLOSE>
		{
			semFuncs.checkArray(ts,t,at);
			if(!at.constante) at.code.addInst(PCodeInstruction.OpCode.DRF);
			if(at.parClass != null && at.parClass == Symbol.ParameterClass.REF) at.code.addInst(PCodeInstruction.OpCode.DRF);
			at.constante = false;
			s = ts.getSymbol(t.image);
			at.parClass = s.parClass;
			at.nivel = s.nivel;
			
			at.code.addComment(" Initial address of array \"" + t.image + "\"");
			at.code.addInst(PCodeInstruction.OpCode.SRF,stack.size()-s.nivel,(int)s.dir);
			if(at.parClass != null && at.parClass == Symbol.ParameterClass.REF) at.code.addInst(PCodeInstruction.OpCode.DRF);
			at.code.addInst(PCodeInstruction.OpCode.PLUS);
			if(at.parClass != null && at.parClass == Symbol.ParameterClass.REF) at.constante = true;
		}
|	t = <tID>
		{
			at.token = t;
			semFuncs.checkVariable(ts,t,at);
			at.constante = false;
			s = ts.getSymbol(t.image);
			at.parClass = s.parClass;
			at.nivel = s.nivel;
			at.code.addComment("Variable / parameter \"" + t.image + "\"");
			at.code.addInst(PCodeInstruction.OpCode.SRF,stack.size()-s.nivel,(int)s.dir);
		}
| 	t = <tNUM>
		{
			at.type = Symbol.Types.INT;
			at.token = t;
			at.constante = true;
			at.code.addInst(PCodeInstruction.OpCode.STC,Integer.valueOf(token.image));
		}
| 	t = <tCARACTER>
		{
			at.type = Symbol.Types.CHAR;
			at.token = t;
			at.constante = true;
			String str = at.token.image;
			at.code.addInst(PCodeInstruction.OpCode.STC,(int)str.charAt(1));
		}
| 	t = <tSTRING>
		{
			at.type = Symbol.Types.STRING;
			at.token = t;
			at.constante = true;
			String str = at.token.image;
			for(int i = 1; i < str.length()-1; i++){
				at.code.addInst(PCodeInstruction.OpCode.STC,(int)str.charAt(i));
				at.code.addInst(PCodeInstruction.OpCode.WRT,0);
			}
		}
| 	t = <tTRUE>
		{
			at.type = Symbol.Types.BOOL;
			at.token = t;
			at.constante = true;
			at.code.addInst(PCodeInstruction.OpCode.STC,1);
		}
| 	t = <tFALSE>
		{
			at.type = Symbol.Types.BOOL;
			at.token = t;
			at.constante = true;
			at.code.addInst(PCodeInstruction.OpCode.STC,0);
		}
}

// factor que contiene paréntesis
// invocaciones a función
// int2char, char2int
void factor_con_par(Attributes at):
{
	Token t;
	Attributes at1 = new Attributes(), at2;
	CodeBlock code1 = new CodeBlock();
	CodeBlock code2 = new CodeBlock();
	Symbol s, s2;
	SymbolArray sa;
	SymbolFunction sp;
	int i, n;
	at1.dir = at.dir;
}
{
	try {
		<tINT2CHAR> <tPOPEN> expresion(at) <tPCLOSE> 
			{
				semFuncs.checkInt(at);
				if(!at.constante) at.code.addInst(PCodeInstruction.OpCode.DRF);
				if(at.parClass != null && at.parClass == Symbol.ParameterClass.REF) at.code.addInst(PCodeInstruction.OpCode.DRF);
				at.type = Symbol.Types.CHAR;
				at.constante = true;
			}
		|	<tCHAR2INT> <tPOPEN> expresion(at) <tPCLOSE>
			{
				semFuncs.checkChar(at);
				if(!at.constante) at.code.addInst(PCodeInstruction.OpCode.DRF);
				if(at.parClass != null && at.parClass == Symbol.ParameterClass.REF) at.code.addInst(PCodeInstruction.OpCode.DRF);
				at.type = Symbol.Types.INT;
				at.constante = true;
			}
		|	LOOKAHEAD(2) t = <tID> <tPOPEN> (lista_una_o_mas_exps(at1))? <tPCLOSE>
			{
				at.token = t;
				at.constante = true;
				semFuncs.checkFunction(ts,t,at);
				semFuncs.comprobacionParametros(at1,t,ts);
				s = ts.getSymbol(t.image);
				sp = (SymbolFunction)s;
				i = 0;
				for(Symbol s1 : sp.parList){
					if(s1.parClass == Symbol.ParameterClass.VAL){
						at2 = at1.par.get(i);
						if(at2.type == Symbol.Types.ARRAY){
							sa = (SymbolArray) ts.getSymbol(at2.token.image);
							code2.addComment(" Variable / parameter \"" + at2.token.image + "\"");
							for(int j = sa.minInd; j <= sa.maxInd; j ++){
								code2.addInst(PCodeInstruction.OpCode.SRF, stack.size()-sa.nivel, (int)sa.dir+j);
								code2.addInst(PCodeInstruction.OpCode.DRF);
							}
							n = i + 1;
							code2.encloseXMLTags("argument_"+n);
							code1.addBlock(code2);
							code2.clearBlock();
						} else {
							
							code2.addBlock(at2.code);
							if(!at2.constante) code2.addInst(PCodeInstruction.OpCode.DRF);
							if(at2.parClass != null && at2.parClass == Symbol.ParameterClass.REF) code2.addInst(PCodeInstruction.OpCode.DRF);
							n = i+1;
							code2.encloseXMLTags("argument_"+n);
							code1.addBlock(code2);
							code2.clearBlock();
						}
					} else if(s1.parClass == Symbol.ParameterClass.REF){
						at2 = at1.par.get(i);
						code2.addBlock(at2.code);
						if(at2.parClass != null && at2.parClass == Symbol.ParameterClass.REF) code2.addInst(PCodeInstruction.OpCode.DRF);
						n = i+1;
						code2.encloseXMLTags("argument_"+n);
						code1.addBlock(code2);
						code2.clearBlock();
					}
					i++;
				}

				code1.addOSFInst((int)at.dir,stack.size()-s.nivel,"L"+s.dir);
				code1.encloseXMLTags("function_call_"+t.image);
				at.code.addBlock(code1);

			}
	} catch(ParseException e){
		Set<Integer> conjSinc = infoParseException(e);
		conjSinc.add(tPCLOSE);
		recuperacionPanico(e.currentToken.next,conjSinc);
	}
}

JAVACODE
Set<Integer> infoParseException(ParseException e){
	Set<Integer> esperados = new HashSet<Integer>();
	System.err.println("ERROR SINT: ('" + e.currentToken.next.image + "'," + e.currentToken.next.beginLine + "," + e.currentToken.next.beginColumn + ")");
	System.err.println("Se esperaba uno de los siguientes tokens:");
	for (int i = 0; i < e.expectedTokenSequences.length ; i++){
		esperados.add(e.expectedTokenSequences[i][0]);
		System.err.println("\t" + adac_4Constants.tokenImage[e.expectedTokenSequences[i][0]]);
	}
	return esperados;
}

JAVACODE
void recuperacionPanico(Token tInesperado, Set<Integer> conjSinc){
	System.err.println("----> Recupero modo pánico: " + "\n----> Saltando todo hasta token de conjunto de sincronización");
	Token t = getNextToken();
	while(!conjSinc.contains(t.kind) && t.kind != EOF){
		System.err.println("Descartando token (" + adac_4Constants.tokenImage[t.kind] + "," + t.image + ")");
		t = getNextToken();
	}
}

JAVACODE
void escribirCodigo(String s){
	try{
		for (int i = 0; i < s.length(); i++)
            f.write(s.charAt(i));
	} catch(IOException e){
		System.err.println("Exception: " + e.getMessage());
	}
}